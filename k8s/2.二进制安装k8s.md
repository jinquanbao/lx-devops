# centos7安装

## 下载官方镜像

访问官方网站：https://www.centos.org/download/

点击 [x86_64](http://isoredirect.centos.org/centos/7/isos/x86_64/) 进入镜像源地址

![image-20220819143622358](./images/image-20220819143622358.png)

选择阿里云镜像地址

![image-20220819144126204](./images/image-20220819144126204.png)



选择标准版或者mini版本下载

![image-20220819144247869](./images/image-20220819144247869.png)

## 创建虚拟机

选择自定义，点击下一步

![image-20220819145326980](./images/image-20220819145326980.png)



![image-20220819145420363](./images/image-20220819145420363.png)



选择稍后安装操作系统，点击下一步

![image-20220819145458450](./images/image-20220819145458450.png)



选择centos7 64操作系统

![image-20220819145713445](./images/image-20220819145713445.png)



填写虚拟机名称与存储路径

![image-20220819145805816](./images/image-20220819145805816.png)





![image-20220819145859977](./images/image-20220819145859977.png)



分配虚拟内存

![image-20220819150110170](./images/image-20220819150110170.png)



选择NAT网络



![image-20220819150234457](./images/image-20220819150234457.png)

指定磁盘容量

![image-20220819150344251](./images/image-20220819150344251.png)



自定义硬件，删除掉无用的声卡、打印机等硬件

![image-20220819145145399](./images/image-20220819145145399.png)



## 安装ios镜像

右键虚拟机点击设置，在CD/DVD选项选择使用IOS镜像文件，选择从官方下载下来的ios文件

![image-20220819151001373](./images/image-20220819151001373.png)



点击开启此虚拟机



![image-20220819151431177](C:\Users\12553\AppData\Roaming\Typora\typora-user-images\image-20220819151431177.png)



点击安装，选择英文，点击确定

![image-20220819151542652](C:\Users\12553\AppData\Roaming\Typora\typora-user-images\image-20220819151542652.png)



点击network &hostname，配置网络与主机名称

![image-20220819153356430](./images/image-20220819153356430.png)



填写host名称，打开以太网配置开关，点击配置

![image-20220819152201190](./images/image-20220819152201190.png)



配置静态IP

![image-20220819153009801](./images/image-20220819153009801.png)



点击INSTALLTION DESTINATION 配置安装目标

![image-20220819153518141](./images/image-20220819153518141.png)



直接选择done

![image-20220819153731604](./images/image-20220819153731604.png)





点击 DATE & TIME 配置时区

![image-20220819154059074](./images/image-20220819154059074.png)

选择上海时区



![image-20220819153941453](./images/image-20220819153941453.png)





配置完成后，点击开始安装

![image-20220819154223541](./images/image-20220819154223541.png)



配置root密码，等待安装完成

![image-20220819154506695](./images/image-20220819154506695.png)



安装完成点击reboot登录

![image-20220819155216699](C:\Users\12553\AppData\Roaming\Typora\typora-user-images\image-20220819155216699.png)



# 集群安装

## 基本环境配置



​													表1-1  高可用Kubernetes集群规划

| 主机名            | IP地址               | 规格                          | 说明             |
| ----------------- | -------------------- | ----------------------------- | ---------------- |
| k8s-master01 ~ 03 | 192.168.23.101 ~ 103 | (cpu-4 内存-2G 硬盘-20G)/节点 | master节点 * 3   |
| k8s-master-lb     | 192.168.23.100       | 虚拟节点                      | keepalived虚拟IP |
| k8s-node01 ~ 02   | 192.168.23.104 ~ 105 | (cpu-4 内存-4G 硬盘-50G)/节点 | worker节点 * 2   |

**请统一替换这些网段，Pod网段和service和宿主机网段不要重复！！！**



| ***\*配置信息\**** | 备注          |
| ------------------ | ------------- |
| 系统版本           | CentOS 7.9    |
| Docker版本         | 20.10.x       |
| Pod网段            | 172.16.0.0/12 |
| Service网段        | 10.96.0.0/12  |



**注意：宿主机网段、K8s Service网段、Pod网段不能重复**

**VIP（虚拟IP）不要和公司内网IP重复，首先去ping一下，不通才可用。VIP需要和你的主机在同一个局域网内（不是直接用我的VIP）！**

**公有云上搭建VIP是公有云的负载均衡的IP，比如阿里云的内网SLB的地址，腾讯云内网ELB的地址。不需要再搭建keepalived和haproxy**



所有节点配置hosts，修改/etc/hosts如下：

请统一替换这些IP地址！！！

```
[root@k8s-master01 ~]# cat /etc/hosts

192.168.23.101 k8s-master01

192.168.23.102 k8s-master02

192.168.23.103 k8s-master03

192.168.23.100 k8s-master-lb # 如果不是高可用集群，该IP为Master01的IP

192.168.23.104 k8s-node01

192.168.23.105 k8s-node02
```



CentOS 7安装yum源如下：

```
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
cat <<EOF > /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo
```



必备工具安装

```
yum install wget jq psmisc vim net-tools telnet yum-utils device-mapper-persistent-data lvm2 git -y
```



所有节点关闭防火墙、selinux、dnsmasq、swap。服务器配置如下：

```
systemctl disable --now firewalld 

#没有dns服务这个命令会报错，不影响
systemctl disable --now dnsmasq
#公有云确认是否需要关闭
systemctl disable --now NetworkManager


setenforce 0
sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/sysconfig/selinux
sed -i 's#SELINUX=enforcing#SELINUX=disabled#g' /etc/selinux/config

#关闭swap分区
swapoff -a && sysctl -w vm.swappiness=0
sed -ri '/^[^#]*swap/s@^@#@' /etc/fstab
```



 

安装ntpdate

```
rpm -ivh http://mirrors.wlnmp.com/centos/wlnmp-release-centos.noarch.rpm
yum install ntpdate -y
```

 

所有节点同步时间。时间同步配置如下：

```
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
echo 'Asia/Shanghai' >/etc/timezone
ntpdate time2.aliyun.com
# 加入到crontab (vi /etc/crontab) 
*/5 * * * * /usr/sbin/ntpdate time2.aliyun.com
```



所有节点配置limit：

```
ulimit -SHn 65535
```

vim /etc/security/limits.conf

**# 末尾添加如下内容**

```
* soft nofile 65536
* hard nofile 131072
* soft nproc 65535
* hard nproc 655350
* soft memlock unlimited
* hard memlock unlimited
```



Master01节点免密钥登录其他节点，安装过程中生成配置文件和证书均在Master01上操作，集群管理也在Master01上操作，阿里云或者AWS上需要单独一台kubectl服务器。密钥配置如下：

```
ssh-keygen -t rsa
for i in k8s-master01 k8s-master02 k8s-master03 k8s-node01 k8s-node02;do ssh-copy-id -i .ssh/id_rsa.pub root@$i;done
```





 

所有节点升级系统并重启，此处升级没有升级内核，下节会单独升级内核：

```
yum update -y --exclude=kernel* && reboot #CentOS7需要升级，CentOS8可以按需升级系统
```

## 内核配置

CentOS7 需要升级内核至4.18+，本地升级的版本为4.19

在master01节点下载内核：

```
cd /root
wget http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-devel-4.19.12-1.el7.elrepo.x86_64.rpm
wget http://193.49.22.109/elrepo/kernel/el7/x86_64/RPMS/kernel-ml-4.19.12-1.el7.elrepo.x86_64.rpm
```

从master01节点传到其他节点：

```
for i in k8s-master02 k8s-master03 k8s-node01 k8s-node02;do scp kernel-ml-4.19.12-1.el7.elrepo.x86_64.rpm kernel-ml-devel-4.19.12-1.el7.elrepo.x86_64.rpm $i:/root/ ; done
```

所有节点安装内核

```
cd /root && yum localinstall -y kernel-ml*
```

所有节点更改内核启动顺序

```
grub2-set-default  0 && grub2-mkconfig -o /etc/grub2.cfg

grubby --args="user_namespace.enable=1" --update-kernel="$(grubby --default-kernel)"
```

检查默认内核是不是4.19

```
[root@k8s-master02 ~]# grubby --default-kernel
/boot/vmlinuz-4.19.12-1.el7.elrepo.x86_64
```

所有节点重启，然后检查内核是不是4.19

```
[root@k8s-master02 ~]# uname -a
Linux k8s-master02 4.19.12-1.el7.elrepo.x86_64 #1 SMP Fri Dec 21 11:06:36 EST 2018 x86_64 x86_64 x86_64 GNU/Linux
```

所有节点安装ipvsadm：

```
yum install ipvsadm ipset sysstat conntrack libseccomp -y
```

所有节点配置ipvs模块，**在内核4.19+版本nf_conntrack_ipv4已经改为nf_conntrack， 4.18以下使用nf_conntrack_ipv4**即可：

```
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack
vim /etc/modules-load.d/ipvs.conf 
	# 加入以下内容
ip_vs
ip_vs_lc
ip_vs_wlc
ip_vs_rr
ip_vs_wrr
ip_vs_lblc
ip_vs_lblcr
ip_vs_dh
ip_vs_sh
ip_vs_fo
ip_vs_nq
ip_vs_sed
ip_vs_ftp
ip_vs_sh
nf_conntrack
ip_tables
ip_set
xt_set
ipt_set
ipt_rpfilter
ipt_REJECT
ipip
```

然后执行systemctl enable --now systemd-modules-load.service即可



开启一些k8s集群中必须的内核参数，所有节点配置k8s内核：

```
cat <<EOF > /etc/sysctl.d/k8s.conf
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
fs.may_detach_mounts = 1
net.ipv4.conf.all.route_localnet = 1
vm.overcommit_memory=1
vm.panic_on_oom=0
fs.inotify.max_user_watches=89100
fs.file-max=52706963
fs.nr_open=52706963
net.netfilter.nf_conntrack_max=2310720

net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_keepalive_intvl =15
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_max_orphans = 327680
net.ipv4.tcp_orphan_retries = 3
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.ip_conntrack_max = 65536
net.ipv4.tcp_max_syn_backlog = 16384
net.ipv4.tcp_timestamps = 0
net.core.somaxconn = 16384
EOF
sysctl --system
```

所有节点配置完内核后，重启服务器，保证重启后内核依旧加载

```
reboot
lsmod | grep --color=auto -e ip_vs -e nf_conntrack
```

## **k8s组件和Runtime安装**

如果安装的版本低于1.24，选择Docker和Containerd均可，高于1.24选择Containerd作为Runtime。

**注意：Runtime安装选择两个小节的其中一个小节即可。**



Master01节点下载安装所有的源码文件：

```
cd /root/ ; git clone https://github.com/dotbalo/k8s-ha-install.git
```

如果无法下载就下载：https://gitee.com/dukuan/k8s-ha-install.git

**Master01节点切换到1.23.x分支**（其他版本可以切换到其他分支，.x即可，不需要更改为具体的小版本）

```
cd /root/k8s-ha-install && git checkout manual-installation-v1.23.x
```





### Containerd作为Runtime

所有节点安装docker-ce-20.10：

```
yum install docker-ce-20.10.* docker-ce-cli-20.10.* -y
```

可以无需启动Docker，只需要配置和启动Containerd即可。

首先配置Containerd所需的模块（所有节点）：

```
# cat <<EOF | sudo tee /etc/modules-load.d/containerd.conf
overlay
br_netfilter
EOF
```

所有节点加载模块：

```
# modprobe -- overlay
# modprobe -- br_netfilter
```

所有节点，配置Containerd所需的内核：

```
# cat <<EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf
net.bridge.bridge-nf-call-iptables  = 1
net.ipv4.ip_forward                 = 1
net.bridge.bridge-nf-call-ip6tables = 1
EOF
```

所有节点加载内核：

```
# sysctl --system
```

所有节点配置Containerd的配置文件：

```
# mkdir -p /etc/containerd
# containerd config default | tee /etc/containerd/config.toml
```

所有节点将Containerd的Cgroup改为Systemd：

```
# vim /etc/containerd/config.toml
```

找到***containerd.runtimes.runc.options，添加*SystemdCgroup = true**（**如果已存在直接修改，否则会报错**），如下图所示：

![image-20220822135253640](./images/image-20220822135253640.png)

所有节点将sandbox_image的Pause镜像改成符合自己版本的地址：

registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6

![image-20220822135424146](./images/image-20220822135424146.png)



所有节点启动Containerd，并配置开机自启动：

```
# systemctl daemon-reload
# systemctl enable --now containerd
```

所有节点配置crictl客户端连接的运行时位置：

```
# cat > /etc/crictl.yaml <<EOF
runtime-endpoint: unix:///run/containerd/containerd.sock
image-endpoint: unix:///run/containerd/containerd.sock
timeout: 10
debug: false
EOF
```

### Docker作为Runtime(小于1.24)

如果选择Docker作为Runtime，安装步骤较Containerd较为简单，只需要安装并启动即可。

所有节点安装docker-ce 20.10：

```
# yum install docker-ce-20.10.* docker-ce-cli-20.10.* -y
```

由于新版Kubelet建议使用systemd，所以把Docker的CgroupDriver也改成systemd：

```
# mkdir /etc/docker
# cat > /etc/docker/daemon.json <<EOF
{
  "exec-opts": ["native.cgroupdriver=systemd"]
}
EOF
```

所有节点设置开机自启动Docker：

```
# systemctl daemon-reload && systemctl enable --now docker
```

### K8s及etcd安装

Master01下载kubernetes安装包（1.23.10需要更改为你看到的最新版本）

```
[root@k8s-master01 ~]# wget https://dl.k8s.io/v1.23.10/kubernetes-server-linux-amd64.tar.gz
```



注意目前版本是1.23.10学员安装时需要下载最新的1.23.x版本：[https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md](https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md)

以下操作都在master01执行

下载etcd安装包(https://github.com/etcd-io/etcd/releases)

```
[root@k8s-master01 ~]# wget https://github.com/etcd-io/etcd/releases/download/v3.5.1/etcd-v3.5.1-linux-amd64.tar.gz
```



解压kubernetes安装文件

```
[root@k8s-master01 ~]# tar -xf kubernetes-server-linux-amd64.tar.gz  --strip-components=3 -C /usr/local/bin kubernetes/server/bin/kube{let,ctl,-apiserver,-controller-manager,-scheduler,-proxy}
```



解压etcd安装文件

```
[root@k8s-master01 ~]#  tar -zxvf etcd-v3.5.1-linux-amd64.tar.gz --strip-components=1 -C /usr/local/bin etcd-v3.5.1-linux-amd64/etcd{,ctl}
```

版本查看

```
[root@k8s-master01 ~]# kubelet --version
Kubernetes v1.23.10
[root@k8s-master01 ~]# etcdctl version
etcdctl version: 3.5.1
API version: 3.5
```

将组件发送到其他节点

```
MasterNodes='k8s-master02 k8s-master03'
WorkNodes='k8s-node01 k8s-node02'
for NODE in $MasterNodes; do echo $NODE; scp /usr/local/bin/kube{let,ctl,-apiserver,-controller-manager,-scheduler,-proxy} $NODE:/usr/local/bin/; scp /usr/local/bin/etcd* $NODE:/usr/local/bin/; done
for NODE in $WorkNodes; do     scp /usr/local/bin/kube{let,-proxy} $NODE:/usr/local/bin/ ; done
```

所有节点创建/opt/cni/bin目录

```
mkdir -p /opt/cni/bin
```



## 生成证书

**注意：二进制安装最关键步骤，一步错误全盘皆输，一定要注意每个步骤都要是正确的**

Master01下载生成证书工具(https://github.com/cloudflare/cfssl/releases?page=2)

```
wget "https://pkg.cfssl.org/R1.2/cfssl_linux-amd64" -O /usr/local/bin/cfssl
wget "https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64" -O /usr/local/bin/cfssljson
chmod +x /usr/local/bin/cfssl /usr/local/bin/cfssljson
```

### etcd证书

所有Master节点创建etcd证书目录

```
mkdir /etc/etcd/ssl -p
```

所有节点创建kubernetes相关目录

```
mkdir -p /etc/kubernetes/pki
```

Master01节点生成etcd证书

生成证书的CSR文件：证书签名请求文件，配置了一些域名、公司、单位

```
[root@k8s-master01 pki]# cd /root/k8s-ha-install/pki

# 生成etcd CA证书和CA证书的key
cfssl gencert -initca etcd-ca-csr.json | cfssljson -bare /etc/etcd/ssl/etcd-ca


cfssl gencert \
   -ca=/etc/etcd/ssl/etcd-ca.pem \
   -ca-key=/etc/etcd/ssl/etcd-ca-key.pem \
   -config=ca-config.json \
   -hostname=127.0.0.1,k8s-master01,k8s-master02,k8s-master03,192.168.23.101,192.168.23.102,192.168.23.103 \
   -profile=kubernetes \
   etcd-csr.json | cfssljson -bare /etc/etcd/ssl/etcd

执行结果
2022/08/24 09:31:50 [INFO] generate received request
2022/08/24 09:31:50 [INFO] received CSR
2022/08/24 09:31:50 [INFO] generating key: rsa-2048
2022/08/24 09:31:51 [INFO] encoded CSR
2022/08/24 09:31:51 [INFO] signed certificate with serial number 268226612591088377066619796590337142102222596243
```

将证书复制到其他节点

```
MasterNodes='k8s-master02 k8s-master03'
WorkNodes='k8s-node01 k8s-node02'

for NODE in $MasterNodes; do
     ssh $NODE "mkdir -p /etc/etcd/ssl"
     for FILE in etcd-ca-key.pem  etcd-ca.pem  etcd-key.pem  etcd.pem; do
       scp /etc/etcd/ssl/${FILE} $NODE:/etc/etcd/ssl/${FILE}
     done
done
```



### k8s组件证书

Master01生成kubernetes证书

```
[root@k8s-master01 pki]# cd /root/k8s-ha-install/pki


#生成统一的根证书
cfssl gencert -initca ca-csr.json | cfssljson -bare /etc/kubernetes/pki/ca
```

**#10.96.0.1是k8s service的网段，如果说需要更改k8s service网段，那就需要更改10.96.0.1**

**\# 如果不是高可用集群，192.168.23.100为Master01的IP**

```
cfssl gencert   -ca=/etc/kubernetes/pki/ca.pem   -ca-key=/etc/kubernetes/pki/ca-key.pem   -config=ca-config.json   -hostname=10.96.0.1,192.168.23.100,127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.default.svc.cluster.local,192.168.23.101,192.168.23.102,192.168.23.103   -profile=kubernetes   apiserver-csr.json | cfssljson -bare /etc/kubernetes/pki/apiserver
```

生成apiserver的聚合证书。Requestheader-client-xxx requestheader-allowwd-xxx:aggerator

```
cfssl gencert   -initca front-proxy-ca-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-ca 

cfssl gencert   -ca=/etc/kubernetes/pki/front-proxy-ca.pem   -ca-key=/etc/kubernetes/pki/front-proxy-ca-key.pem   -config=ca-config.json   -profile=kubernetes   front-proxy-client-csr.json | cfssljson -bare /etc/kubernetes/pki/front-proxy-client
```

返回结果（忽略警告）

```
2022/08/24 09:34:41 [INFO] generate received request
2022/08/24 09:34:41 [INFO] received CSR
2022/08/24 09:34:41 [INFO] generating key: rsa-2048
2022/08/24 09:34:41 [INFO] encoded CSR
2022/08/24 09:34:41 [INFO] signed certificate with serial number 169066291263495298754487796267253787453039257463
2022/08/24 09:34:41 [WARNING] This certificate lacks a "hosts" field. This makes it unsuitable for
websites. For more information see the Baseline Requirements for the Issuance and Management
of Publicly-Trusted Certificates, v.1.1.6, from the CA/Browser Forum (https://cabforum.org);
specifically, section 10.2.3 ("Information Requirements").
```

\# 生成controller-manage的证书

```
cfssl gencert \
   -ca=/etc/kubernetes/pki/ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-key.pem \
   -config=ca-config.json \
   -profile=kubernetes \
   manager-csr.json | cfssljson -bare /etc/kubernetes/pki/controller-manager

# 注意，如果不是高可用集群，192.168.23.100:8443改为master01的地址，8443改为apiserver的端口，默认是6443
# set-cluster：设置一个集群项，

kubectl config set-cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/ca.pem \
     --embed-certs=true \
     --server=https://192.168.23.100:8443 \
     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig

# 设置一个环境项，一个上下文
kubectl config set-context system:kube-controller-manager@kubernetes \
    --cluster=kubernetes \
    --user=system:kube-controller-manager \
    --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig

# set-credentials 设置一个用户项

kubectl config set-credentials system:kube-controller-manager \
     --client-certificate=/etc/kubernetes/pki/controller-manager.pem \
     --client-key=/etc/kubernetes/pki/controller-manager-key.pem \
     --embed-certs=true \
     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig


# 使用某个环境当做默认环境

kubectl config use-context system:kube-controller-manager@kubernetes \
     --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig



cfssl gencert \
   -ca=/etc/kubernetes/pki/ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-key.pem \
   -config=ca-config.json \
   -profile=kubernetes \
   scheduler-csr.json | cfssljson -bare /etc/kubernetes/pki/scheduler

# 注意，如果不是高可用集群，192.168.23.100:8443改为master01的地址，8443改为apiserver的端口，默认是6443

kubectl config set-cluster kubernetes \
     --certificate-authority=/etc/kubernetes/pki/ca.pem \
     --embed-certs=true \
     --server=https://192.168.23.100:8443 \
     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig


kubectl config set-credentials system:kube-scheduler \
     --client-certificate=/etc/kubernetes/pki/scheduler.pem \
     --client-key=/etc/kubernetes/pki/scheduler-key.pem \
     --embed-certs=true \
     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig

kubectl config set-context system:kube-scheduler@kubernetes \
     --cluster=kubernetes \
     --user=system:kube-scheduler \
     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig


kubectl config use-context system:kube-scheduler@kubernetes \
     --kubeconfig=/etc/kubernetes/scheduler.kubeconfig


cfssl gencert \
   -ca=/etc/kubernetes/pki/ca.pem \
   -ca-key=/etc/kubernetes/pki/ca-key.pem \
   -config=ca-config.json \
   -profile=kubernetes \
   admin-csr.json | cfssljson -bare /etc/kubernetes/pki/admin

# 注意，如果不是高可用集群，192.168.23.100:8443改为master01的地址，8443改为apiserver的端口，默认是6443

kubectl config set-cluster kubernetes     --certificate-authority=/etc/kubernetes/pki/ca.pem     --embed-certs=true     --server=https://192.168.23.100:8443     --kubeconfig=/etc/kubernetes/admin.kubeconfig
kubectl config set-credentials kubernetes-admin     --client-certificate=/etc/kubernetes/pki/admin.pem     --client-key=/etc/kubernetes/pki/admin-key.pem     --embed-certs=true     --kubeconfig=/etc/kubernetes/admin.kubeconfig


kubectl config set-context kubernetes-admin@kubernetes     --cluster=kubernetes     --user=kubernetes-admin     --kubeconfig=/etc/kubernetes/admin.kubeconfig


kubectl config use-context kubernetes-admin@kubernetes     --kubeconfig=/etc/kubernetes/admin.kubeconfig
```

创建ServiceAccount Key à secret

```
openssl genrsa -out /etc/kubernetes/pki/sa.key 2048

openssl rsa -in /etc/kubernetes/pki/sa.key -pubout -out /etc/kubernetes/pki/sa.pub
```

发送证书至其他节点

```
MasterNodes='k8s-master02 k8s-master03'
for NODE in $MasterNodes; do     
     for FILE in $(ls /etc/kubernetes/pki | grep -v etcd); do
         scp /etc/kubernetes/pki/${FILE} $NODE:/etc/kubernetes/pki/${FILE}
     done
     for FILE in admin.kubeconfig controller-manager.kubeconfig scheduler.kubeconfig; do
       scp /etc/kubernetes/${FILE} $NODE:/etc/kubernetes/${FILE}
     done
done
```



查看证书文件

```
[root@k8s-master01 pki]# ls /etc/kubernetes/pki/
admin.csr      apiserver.csr      ca.csr      controller-manager.csr      front-proxy-ca.csr      front-proxy-client.csr      sa.key         scheduler-key.pem
admin-key.pem  apiserver-key.pem  ca-key.pem  controller-manager-key.pem  front-proxy-ca-key.pem  front-proxy-client-key.pem  sa.pub         scheduler.pem
admin.pem      apiserver.pem      ca.pem      controller-manager.pem      front-proxy-ca.pem      front-proxy-client.pem      scheduler.csr
[root@k8s-master01 pki]# ls /etc/kubernetes/pki/ |wc -l
23
```



## Kubernetes系统组件配置

### Etcd配置

#### Master01配置

vim /etc/etcd/etcd.config.yml

```
name: 'k8s-master01'
data-dir: /var/lib/etcd
wal-dir: /var/lib/etcd/wal
snapshot-count: 5000
heartbeat-interval: 100
election-timeout: 1000
quota-backend-bytes: 0
listen-peer-urls: 'https://192.168.23.101:2380'
listen-client-urls: 'https://192.168.23.101:2379,http://127.0.0.1:2379'
max-snapshots: 3
max-wals: 5
cors:
initial-advertise-peer-urls: 'https://192.168.23.101:2380'
advertise-client-urls: 'https://192.168.23.101:2379'
discovery:
discovery-fallback: 'proxy'
discovery-proxy:
discovery-srv:
initial-cluster: 'k8s-master01=https://192.168.23.101:2380,k8s-master02=https://192.168.23.102:2380,k8s-master03=https://192.168.23.103:2380'
initial-cluster-token: 'etcd-k8s-cluster'
initial-cluster-state: 'new'
strict-reconfig-check: false
enable-v2: true
enable-pprof: true
proxy: 'off'
proxy-failure-wait: 5000
proxy-refresh-interval: 30000
proxy-dial-timeout: 1000
proxy-write-timeout: 5000
proxy-read-timeout: 0
client-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  auto-tls: true
peer-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  peer-client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  auto-tls: true
debug: false
log-package-levels:
log-outputs: [default]
force-new-cluster: false
```



#### Master02配置

vim /etc/etcd/etcd.config.yml

```
name: 'k8s-master02'
data-dir: /var/lib/etcd
wal-dir: /var/lib/etcd/wal
snapshot-count: 5000
heartbeat-interval: 100
election-timeout: 1000
quota-backend-bytes: 0
listen-peer-urls: 'https://192.168.23.102:2380'
listen-client-urls: 'https://192.168.23.102:2379,http://127.0.0.1:2379'
max-snapshots: 3
max-wals: 5
cors:
initial-advertise-peer-urls: 'https://192.168.23.102:2380'
advertise-client-urls: 'https://192.168.23.102:2379'
discovery:
discovery-fallback: 'proxy'
discovery-proxy:
discovery-srv:
initial-cluster: 'k8s-master01=https://192.168.23.101:2380,k8s-master02=https://192.168.23.102:2380,k8s-master03=https://192.168.23.103:2380'
initial-cluster-token: 'etcd-k8s-cluster'
initial-cluster-state: 'new'
strict-reconfig-check: false
enable-v2: true
enable-pprof: true
proxy: 'off'
proxy-failure-wait: 5000
proxy-refresh-interval: 30000
proxy-dial-timeout: 1000
proxy-write-timeout: 5000
proxy-read-timeout: 0
client-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  auto-tls: true
peer-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  peer-client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  auto-tls: true
debug: false
log-package-levels:
log-outputs: [default]
force-new-cluster: false
```



#### Master03配置

vim /etc/etcd/etcd.config.yml

```
name: 'k8s-master03'
data-dir: /var/lib/etcd
wal-dir: /var/lib/etcd/wal
snapshot-count: 5000
heartbeat-interval: 100
election-timeout: 1000
quota-backend-bytes: 0
listen-peer-urls: 'https://192.168.23.103:2380'
listen-client-urls: 'https://192.168.23.103:2379,http://127.0.0.1:2379'
max-snapshots: 3
max-wals: 5
cors:
initial-advertise-peer-urls: 'https://192.168.23.103:2380'
advertise-client-urls: 'https://192.168.23.103:2379'
discovery:
discovery-fallback: 'proxy'
discovery-proxy:
discovery-srv:
initial-cluster: 'k8s-master01=https://192.168.23.101:2380,k8s-master02=https://192.168.23.102:2380,k8s-master03=https://192.168.23.103:2380'
initial-cluster-token: 'etcd-k8s-cluster'
initial-cluster-state: 'new'
strict-reconfig-check: false
enable-v2: true
enable-pprof: true
proxy: 'off'
proxy-failure-wait: 5000
proxy-refresh-interval: 30000
proxy-dial-timeout: 1000
proxy-write-timeout: 5000
proxy-read-timeout: 0
client-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  auto-tls: true
peer-transport-security:
  cert-file: '/etc/kubernetes/pki/etcd/etcd.pem'
  key-file: '/etc/kubernetes/pki/etcd/etcd-key.pem'
  peer-client-cert-auth: true
  trusted-ca-file: '/etc/kubernetes/pki/etcd/etcd-ca.pem'
  auto-tls: true
debug: false
log-package-levels:
log-outputs: [default]
force-new-cluster: false
```

#### 创建Service

**所有Master节点**创建etcd service并启动
vim /usr/lib/systemd/system/etcd.service

```
[Unit]
Description=Etcd Service
Documentation=https://coreos.com/etcd/docs/latest/
After=network.target

[Service]
Type=notify
ExecStart=/usr/local/bin/etcd --config-file=/etc/etcd/etcd.config.yml
Restart=on-failure
RestartSec=10
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
Alias=etcd3.service
```

**所有Master节点**创建etcd的证书目录

```
mkdir /etc/kubernetes/pki/etcd
ln -s /etc/etcd/ssl/* /etc/kubernetes/pki/etcd/
systemctl daemon-reload
systemctl enable --now etcd
```

查看etcd状态

```
[root@k8s-master01 pki]# etcdctl --endpoints="192.168.23.103:2379,192.168.23.102:2379,192.168.23.101:2379" --cacert=/etc/kubernetes/pki/etcd/etcd-ca.pem --cert=/etc/kubernetes/pki/etcd/etcd.pem --key=/etc/kubernetes/pki/etcd/etcd-key.pem  endpoint status --write-out=table
```

响应结果：

```
+---------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|      ENDPOINT       |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+---------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
| 192.168.23.103:2379 | 4038e0996c426336 |   3.5.1 |   25 kB |     false |      false |         2 |          8 |                  8 |        |
| 192.168.23.102:2379 | 8387b2439596db60 |   3.5.1 |   20 kB |     false |      false |         2 |          8 |                  8 |        |
| 192.168.23.101:2379 | e9ee496766ad2993 |   3.5.1 |   20 kB |      true |      false |         2 |          8 |                  8 |        |
+---------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
```





## 高可用组件安装

**（注意：如果不是高可用集群，haproxy和keepalived无需安装）**

**公有云要用公有云自带的负载均衡，比如阿里云的SLB，腾讯云的ELB，用来替代haproxy和keepalived，因为公有云大部分都是不支持keepalived的，另外如果用阿里云的话，kubectl控制端不能放在master节点，推荐使用腾讯云，因为阿里云的slb有回环的问题，也就是slb代理的服务器不能反向访问SLB，但是腾讯云修复了这个问题。**



所有Master节点通过yum安装HAProxy和KeepAlived：

```
yum install keepalived haproxy -y
```

所有Master节点配置HAProxy（详细配置参考HAProxy文档，所有Master节点的HAProxy配置相同）：

**注意VIP的IP和端口号**，后续k8s相关组件配置需要用到

```
[root@k8s-master01 etc]# mkdir /etc/haproxy
[root@k8s-master01 etc]# vim /etc/haproxy/haproxy.cfg 
global
  maxconn  2000
  ulimit-n  16384
  log  127.0.0.1 local0 err
  stats timeout 30s

defaults
  log global
  mode  http
  option  httplog
  timeout connect 5000
  timeout client  50000
  timeout server  50000
  timeout http-request 15s
  timeout http-keep-alive 15s

frontend monitor-in
  bind *:33305
  mode http
  option httplog
  monitor-uri /monitor

frontend k8s-master
  bind 0.0.0.0:8443
  bind 127.0.0.1:8443
  mode tcp
  option tcplog
  tcp-request inspect-delay 5s
  default_backend k8s-master

backend k8s-master
  mode tcp
  option tcplog
  option tcp-check
  balance roundrobin
  default-server inter 10s downinter 5s rise 2 fall 2 slowstart 60s maxconn 250 maxqueue 256 weight 100
  server k8s-master01	192.168.23.101:6443  check
  server k8s-master02	192.168.23.102:6443  check
  server k8s-master03	192.168.23.103:6443  check
```



所有Master节点配置KeepAlived，配置不一样，注意区分，**注意每个节点的IP和网卡（interface参数）**

 Master01节点的配置：

```
[root@k8s-master01 ~]# vim /etc/keepalived/keepalived.conf 
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
script_user root
    enable_script_security
}
vrrp_script chk_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 5
    weight -5
    fall 2  
rise 1
}
vrrp_instance VI_1 {
    state MASTER
    interface ens33
    mcast_src_ip 192.168.23.101
    virtual_router_id 51
    priority 101
    advert_int 2
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.23.100
    }
    track_script {
       chk_apiserver
    }
}
```

Master02节点的配置：

```
[root@k8s-master02 ~]# vim /etc/keepalived/keepalived.conf 
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
script_user root
    enable_script_security
}
vrrp_script chk_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 5
    weight -5
    fall 2  
    rise 1
}
vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    mcast_src_ip 192.168.23.102
    virtual_router_id 51
    priority 100
    advert_int 2
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.23.100
    }
    track_script {
       chk_apiserver
    }
}
```

Master03节点的配置：



```
[root@k8s-master03 ~]# vim /etc/keepalived/keepalived.conf 
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
script_user root
    enable_script_security
}
vrrp_script chk_apiserver {
    script "/etc/keepalived/check_apiserver.sh"
    interval 5
    weight -5
    fall 2  
    rise 1
}
vrrp_instance VI_1 {
    state BACKUP
    interface ens33
    mcast_src_ip 192.168.23.103
    virtual_router_id 51
    priority 100
    advert_int 2
    authentication {
        auth_type PASS
        auth_pass K8SHA_KA_AUTH
    }
    virtual_ipaddress {
        192.168.23.100
    }
    track_script {
       chk_apiserver
    }
}
```

所有master节点配置KeepAlived健康检查文件：

```
[root@k8s-master01 keepalived]# vi /etc/keepalived/check_apiserver.sh 
#!/bin/bash

err=0
for k in $(seq 1 3)
do
    check_code=$(pgrep haproxy)
    if [[ $check_code == "" ]]; then
        err=$(expr $err + 1)
        sleep 1
        continue
    else
        err=0
        break
    fi
done

if [[ $err != "0" ]]; then
    echo "systemctl stop keepalived"
    /usr/bin/systemctl stop keepalived
    exit 1
else
    exit 0
fi
```

添加脚本可执行权限

```
chmod +x /etc/keepalived/check_apiserver.sh
```

启动haproxy和keepalived

```
[root@k8s-master01 keepalived]# systemctl daemon-reload
[root@k8s-master01 keepalived]# systemctl enable --now haproxy
[root@k8s-master01 keepalived]# systemctl enable --now keepalived
```

**重要：如果安装了keepalived和haproxy，需要测试keepalived是否是正常的**

```
#测试VIP
[root@k8s-master01 ~]# ping 192.168.23.100 -c 4
PING 192.168.23.100 (192.168.23.100) 56(84) bytes of data.
64 bytes from 192.168.23.100: icmp_seq=1 ttl=64 time=0.464 ms
64 bytes from 192.168.23.100: icmp_seq=2 ttl=64 time=0.063 ms
64 bytes from 192.168.23.100: icmp_seq=3 ttl=64 time=0.062 ms
64 bytes from 192.168.23.100: icmp_seq=4 ttl=64 time=0.063 ms

--- 192.168.23.100 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3106ms
rtt min/avg/max/mdev = 0.062/0.163/0.464/0.173 ms

[root@k8s-master01 ~]# telnet 192.168.23.100 8443
Trying 192.168.23.100...
Connected to 192.168.23.100.
Escape character is '^]'.
Connection closed by foreign host.
```

如果ping不通且telnet没有出现 ] ，则认为VIP不可以，不可在继续往下执行，需要排查keepalived的问题，比如防火墙和selinux，haproxy和keepalived的状态，监听端口等

所有节点查看防火墙状态必须为disable和inactive：systemctl status firewalld

所有节点查看selinux状态，必须为disable：getenforce

master节点查看haproxy和keepalived状态：systemctl status keepalived haproxy

master节点查看监听端口：netstat -lntp



## Kubernetes组件配置

**所有节点**创建相关目录

```
mkdir -p /etc/kubernetes/manifests/ /etc/systemd/system/kubelet.service.d /var/lib/kubelet /var/log/kubernetes
```

### Apiserver

所有Master节点创建kube-apiserver service，**# 注意，如果不是高可用集群，192.168.23.100改为master01的地址**

#### Master01配置

**注意本文档使用的k8s service网段为10.96.0.0/12，该网段不能和宿主机的网段、Pod网段的重复，请按需修改**

vim /usr/lib/systemd/system/kube-apiserver.service 

```
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-apiserver \
      --v=2  \
      --logtostderr=true  \
      --allow-privileged=true  \
      --bind-address=0.0.0.0  \
      --secure-port=6443  \
      --insecure-port=0  \
      --advertise-address=192.168.23.101 \
      --service-cluster-ip-range=10.96.0.0/12  \
      --service-node-port-range=30000-32767  \
      --etcd-servers=https://192.168.23.101:2379,https://192.168.23.102:2379,https://192.168.23.103:2379 \
      --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem  \
      --etcd-certfile=/etc/etcd/ssl/etcd.pem  \
      --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem  \
      --client-ca-file=/etc/kubernetes/pki/ca.pem  \
      --tls-cert-file=/etc/kubernetes/pki/apiserver.pem  \
      --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem  \
      --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem  \
      --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem  \
      --service-account-key-file=/etc/kubernetes/pki/sa.pub  \
      --service-account-signing-key-file=/etc/kubernetes/pki/sa.key  \
      --service-account-issuer=https://kubernetes.default.svc.cluster.local \
      --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \
      --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \
      --authorization-mode=Node,RBAC  \
      --enable-bootstrap-token-auth=true  \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \
      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \
      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \
      --requestheader-allowed-names=aggregator  \
      --requestheader-group-headers=X-Remote-Group  \
      --requestheader-extra-headers-prefix=X-Remote-Extra-  \
      --requestheader-username-headers=X-Remote-User
      # --token-auth-file=/etc/kubernetes/token.csv

Restart=on-failure
RestartSec=10s
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

#### Master02配置

**注意本文档使用的k8s service网段为10.96.0.0/12，该网段不能和宿主机的网段、Pod网段的重复，请按需修改**

vim /usr/lib/systemd/system/kube-apiserver.service 

```
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-apiserver \
      --v=2  \
      --logtostderr=true  \
      --allow-privileged=true  \
      --bind-address=0.0.0.0  \
      --secure-port=6443  \
      --insecure-port=0  \
      --advertise-address=192.168.23.102 \
      --service-cluster-ip-range=10.96.0.0/12  \
      --service-node-port-range=30000-32767  \
      --etcd-servers=https://192.168.23.101:2379,https://192.168.23.102:2379,https://192.168.23.103:2379 \
      --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem  \
      --etcd-certfile=/etc/etcd/ssl/etcd.pem  \
      --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem  \
      --client-ca-file=/etc/kubernetes/pki/ca.pem  \
      --tls-cert-file=/etc/kubernetes/pki/apiserver.pem  \
      --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem  \
      --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem  \
      --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem  \
      --service-account-key-file=/etc/kubernetes/pki/sa.pub  \
      --service-account-signing-key-file=/etc/kubernetes/pki/sa.key  \
      --service-account-issuer=https://kubernetes.default.svc.cluster.local \
      --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \
      --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \
      --authorization-mode=Node,RBAC  \
      --enable-bootstrap-token-auth=true  \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \
      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \
      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \
      --requestheader-allowed-names=aggregator  \
      --requestheader-group-headers=X-Remote-Group  \
      --requestheader-extra-headers-prefix=X-Remote-Extra-  \
      --requestheader-username-headers=X-Remote-User
      # --token-auth-file=/etc/kubernetes/token.csv

Restart=on-failure
RestartSec=10s
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

#### Master03配置

**注意本文档使用的k8s service网段为10.96.0.0/12，该网段不能和宿主机的网段、Pod网段的重复，请按需修改**

vim /usr/lib/systemd/system/kube-apiserver.service 

```
[Unit]
Description=Kubernetes API Server
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-apiserver \
      --v=2  \
      --logtostderr=true  \
      --allow-privileged=true  \
      --bind-address=0.0.0.0  \
      --secure-port=6443  \
      --insecure-port=0  \
      --advertise-address=192.168.23.103 \
      --service-cluster-ip-range=10.96.0.0/12  \
      --service-node-port-range=30000-32767  \
      --etcd-servers=https://192.168.23.101:2379,https://192.168.23.102:2379,https://192.168.23.103:2379 \
      --etcd-cafile=/etc/etcd/ssl/etcd-ca.pem  \
      --etcd-certfile=/etc/etcd/ssl/etcd.pem  \
      --etcd-keyfile=/etc/etcd/ssl/etcd-key.pem  \
      --client-ca-file=/etc/kubernetes/pki/ca.pem  \
      --tls-cert-file=/etc/kubernetes/pki/apiserver.pem  \
      --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem  \
      --kubelet-client-certificate=/etc/kubernetes/pki/apiserver.pem  \
      --kubelet-client-key=/etc/kubernetes/pki/apiserver-key.pem  \
      --service-account-key-file=/etc/kubernetes/pki/sa.pub  \
      --service-account-signing-key-file=/etc/kubernetes/pki/sa.key  \
      --service-account-issuer=https://kubernetes.default.svc.cluster.local \
      --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname  \
      --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,ResourceQuota  \
      --authorization-mode=Node,RBAC  \
      --enable-bootstrap-token-auth=true  \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem  \
      --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.pem  \
      --proxy-client-key-file=/etc/kubernetes/pki/front-proxy-client-key.pem  \
      --requestheader-allowed-names=aggregator  \
      --requestheader-group-headers=X-Remote-Group  \
      --requestheader-extra-headers-prefix=X-Remote-Extra-  \
      --requestheader-username-headers=X-Remote-User
      # --token-auth-file=/etc/kubernetes/token.csv

Restart=on-failure
RestartSec=10s
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```

#### 启动apiserver

所有Master节点开启kube-apiserver

```
systemctl daemon-reload && systemctl enable --now kube-apiserver
```

检测kube-server状态

```
# systemctl status kube-apiserver

● kube-apiserver.service - Kubernetes API Server
   Loaded: loaded (/usr/lib/systemd/system/kube-apiserver.service; enabled; vendor preset: disabled)
   Active: active (running) since Wed 2022-08-24 10:20:49 CST; 15s ago
```

如果系统日志有这些提示可以忽略

```
Dec 11 20:51:15 k8s-master01 kube-apiserver: I1211 20:51:15.004739    7450 clientconn.go:948] ClientConn switching balancer to "pick_first"
Dec 11 20:51:15 k8s-master01 kube-apiserver: I1211 20:51:15.004843    7450 balancer_conn_wrappers.go:78] pickfirstBalancer: HandleSubConnStateChange: 0xc011bd4c80, {CONNECTING <nil>}
Dec 11 20:51:15 k8s-master01 kube-apiserver: I1211 20:51:15.010725    7450 balancer_conn_wrappers.go:78] pickfirstBalancer: HandleSubConnStateChange: 0xc011bd4c80, {READY <nil>}
Dec 11 20:51:15 k8s-master01 kube-apiserver: I1211 20:51:15.011370    7450 controlbuf.go:508] transport: loopyWriter.run returning. connection error: desc = "transport is closing"
```



### ControllerManager

所有Master节点配置kube-controller-manager service（所有master节点配置一样）

**注意本文档使用的k8s Pod网段为172.16.0.0/12，该网段不能和宿主机的网段、k8s Service网段的重复，请按需修改**

vim /usr/lib/systemd/system/kube-controller-manager.service

```
[Unit]
Description=Kubernetes Controller Manager
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-controller-manager \
      --v=2 \
      --logtostderr=true \
      --address=127.0.0.1 \
      --root-ca-file=/etc/kubernetes/pki/ca.pem \
      --cluster-signing-cert-file=/etc/kubernetes/pki/ca.pem \
      --cluster-signing-key-file=/etc/kubernetes/pki/ca-key.pem \
      --service-account-private-key-file=/etc/kubernetes/pki/sa.key \
      --kubeconfig=/etc/kubernetes/controller-manager.kubeconfig \
      --leader-elect=true \
      --use-service-account-credentials=true \
      --node-monitor-grace-period=40s \
      --node-monitor-period=5s \
      --pod-eviction-timeout=2m0s \
      --controllers=*,bootstrapsigner,tokencleaner \
      --allocate-node-cidrs=true \
      --cluster-cidr=172.16.0.0/12 \
      --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.pem \
      --node-cidr-mask-size=24
      
Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

所有Master节点启动kube-controller-manager

```
[root@k8s-master01 pki]# systemctl daemon-reload

[root@k8s-master01 pki]# systemctl enable --now kube-controller-manager
Created symlink /etc/systemd/system/multi-user.target.wants/kube-controller-manager.service → /usr/lib/systemd/system/kube-controller-manager.service.
```

查看启动状态

```
[root@k8s-master01 pki]# systemctl  status kube-controller-manager
● kube-controller-manager.service - Kubernetes Controller Manager
   Loaded: loaded (/usr/lib/systemd/system/kube-controller-manager.service; enabled; vendor preset: disabled)
   Active: active (running) since Wed 2022-08-24 10:24:34 CST; 45s ago
     Docs: https://github.com/kubernetes/kubernetes
 Main PID: 7518 (kube-controller)
```



### Scheduler

所有Master节点配置kube-scheduler service（所有master节点配置一样）

vim /usr/lib/systemd/system/kube-scheduler.service 

```
[Unit]
Description=Kubernetes Scheduler
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-scheduler \
      --v=2 \
      --logtostderr=true \
      --address=127.0.0.1 \
      --leader-elect=true \
      --kubeconfig=/etc/kubernetes/scheduler.kubeconfig

Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

所有Master节点启动kube-scheduler

```
[root@k8s-master01 pki]# systemctl daemon-reload

[root@k8s-master01 pki]# systemctl enable --now kube-scheduler
Created symlink /etc/systemd/system/multi-user.target.wants/kube-scheduler.service → /usr/lib/systemd/system/kube-scheduler.service.
```

查看启动状态

```
[root@k8s-master01 pki]# systemctl  status kube-scheduler
● kube-scheduler.service - Kubernetes Scheduler
   Loaded: loaded (/usr/lib/systemd/system/kube-scheduler.service; enabled; vendor preset: disabled)
   Active: active (running) since Wed 2022-08-24 10:26:43 CST; 53s ago
     Docs: https://github.com/kubernetes/kubernetes
 Main PID: 3046 (kube-scheduler)
```



## TLS Bootstrapping配置

为工作节点自动颁发证书

只需要在Master01创建bootstrap

**\# 注意，如果不是高可用集群，192.168.23.100:8443改为master01的地址，8443改为apiserver的端口，默认是6443**

```
cd /root/k8s-ha-install/bootstrap

kubectl config set-cluster kubernetes     --certificate-authority=/etc/kubernetes/pki/ca.pem     --embed-certs=true     --server=https://192.168.23.100:8443     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig

kubectl config set-credentials tls-bootstrap-token-user     --token=c8ad9c.2e4d610cf3e7426e --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig

kubectl config set-context tls-bootstrap-token-user@kubernetes     --cluster=kubernetes     --user=tls-bootstrap-token-user     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig

kubectl config use-context tls-bootstrap-token-user@kubernetes     --kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig
```

注意：如果要修改bootstrap.secret.yaml的token-id和token-secret，需要保证下图红圈内的字符串一致的，并且位数是一样的。还要保证上个命令的token：c8ad9c.2e4d610cf3e7426e与你修改的字符串要一致

![image-20220823143403070](./images/image-20220823143403070.png)



```
[root@k8s-master01 bootstrap]# mkdir -p /root/.kube ; cp /etc/kubernetes/admin.kubeconfig /root/.kube/config
```

可以正常查询集群状态，才可以继续往下，否则不行，需要排查k8s组件是否有故障

```
[root@k8s-master01 ~]# kubectl get cs
Warning: v1 ComponentStatus is deprecated in v1.19+
NAME                 STATUS    MESSAGE                         ERROR
scheduler            Healthy   ok                              
controller-manager   Healthy   ok                              
etcd-0               Healthy   {"health":"true","reason":""}   
etcd-2               Healthy   {"health":"true","reason":""}   
etcd-1               Healthy   {"health":"true","reason":""}
```



```
[root@k8s-master01 bootstrap]# kubectl create -f bootstrap.secret.yaml 
secret/bootstrap-token-c8ad9c created
clusterrolebinding.rbac.authorization.k8s.io/kubelet-bootstrap created
clusterrolebinding.rbac.authorization.k8s.io/node-autoapprove-bootstrap created
clusterrolebinding.rbac.authorization.k8s.io/node-autoapprove-certificate-rotation created
clusterrole.rbac.authorization.k8s.io/system:kube-apiserver-to-kubelet created
clusterrolebinding.rbac.authorization.k8s.io/system:kube-apiserver created
```





## Node节点的配置

### 复制证书

Master01节点复制证书至Node节点

```
cd /etc/kubernetes/

for NODE in k8s-master02 k8s-master03 k8s-node01 k8s-node02; do
     ssh $NODE mkdir -p /etc/kubernetes/pki /etc/etcd/ssl /etc/etcd/ssl
     for FILE in etcd-ca.pem etcd.pem etcd-key.pem; do
       scp /etc/etcd/ssl/$FILE $NODE:/etc/etcd/ssl/
     done
     for FILE in pki/ca.pem pki/ca-key.pem pki/front-proxy-ca.pem bootstrap-kubelet.kubeconfig; do
       scp /etc/kubernetes/$FILE $NODE:/etc/kubernetes/${FILE}
     done
done
```

执行结果：

```
etcd-ca.pem                                                                                                                                                                    100% 1363   314.0KB/s   00:00    
etcd.pem                                                                                                                                                                       100% 1505   429.1KB/s   00:00    
etcd-key.pem                                                                                                                                                                   100% 1679   361.9KB/s   00:00    
ca.pem                                                                                                                                                                         100% 1407   459.5KB/s   00:00    
ca-key.pem                                                                                                                                                                     100% 1679   475.2KB/s   00:00    
front-proxy-ca.pem                                                                                                                                                             100% 1143   214.5KB/s   00:00    
bootstrap-kubelet.kubeconfig                                                                                                                                                   100% 2291   695.1KB/s   00:00    
etcd-ca.pem                                                                                                                                                                    100% 1363   325.5KB/s   00:00    
etcd.pem                                                                                                                                                                       100% 1505   301.2KB/s   00:00    
etcd-key.pem                                                                                                                                                                   100% 1679   260.9KB/s   00:00    
ca.pem                                                                                                                                                                         100% 1407   420.8KB/s   00:00    
ca-key.pem                                                                                                                                                                     100% 1679   398.0KB/s   00:00    
front-proxy-ca.pem                                                                                                                                                             100% 1143   224.9KB/s   00:00    
bootstrap-kubelet.kubeconfig                                                                                                                                                   100% 2291   685.4KB/s   00:00
```

### kubelet配置

所有节点创建相关目录

```
mkdir -p /var/lib/kubelet /var/log/kubernetes /etc/systemd/system/kubelet.service.d /etc/kubernetes/manifests/
```



所有节点配置kubelet service

vim  /usr/lib/systemd/system/kubelet.service

```
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kubelet

Restart=always
StartLimitInterval=0
RestartSec=10

[Install]
WantedBy=multi-user.target
```

 

**如果Runtime为Containerd，请使用如下Kubelet的配置：**

所有节点配置kubelet service的配置文件（也可以写到kubelet.service）：

```
# Runtime为Containerd
# vim /etc/systemd/system/kubelet.service.d/10-kubelet.conf

[Service]
Environment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig --kubeconfig=/etc/kubernetes/kubelet.kubeconfig"
Environment="KUBELET_SYSTEM_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin --container-runtime=remote --runtime-request-timeout=15m --container-runtime-endpoint=unix:///run/containerd/containerd.sock --cgroup-driver=systemd"
Environment="KUBELET_CONFIG_ARGS=--config=/etc/kubernetes/kubelet-conf.yml"
Environment="KUBELET_EXTRA_ARGS=--node-labels=node.kubernetes.io/node='' "
ExecStart=
ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_SYSTEM_ARGS $KUBELET_EXTRA_ARGS
```

**如果Runtime为Docker，请使用如下Kubelet的配置：**

```
# Runtime为Docker
# vim /etc/systemd/system/kubelet.service.d/10-kubelet.conf

[Service]
Environment="KUBELET_KUBECONFIG_ARGS=--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig --kubeconfig=/etc/kubernetes/kubelet.kubeconfig"
Environment="KUBELET_SYSTEM_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin"
Environment="KUBELET_CONFIG_ARGS=--config=/etc/kubernetes/kubelet-conf.yml --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5"
Environment="KUBELET_EXTRA_ARGS=--node-labels=node.kubernetes.io/node='' "
ExecStart=
ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_SYSTEM_ARGS $KUBELET_EXTRA_ARGS
```



创建kubelet的配置文件

**注意：如果更改了k8s的service网段，需要更改kubelet-conf.yml 的clusterDNS:配置，改成k8s Service网段的第十个地址，比如10.96.0.10**

```
[root@k8s-master01 bootstrap]# vim /etc/kubernetes/kubelet-conf.yml
```

```
apiVersion: kubelet.config.k8s.io/v1beta1
kind: KubeletConfiguration
address: 0.0.0.0
port: 10250
readOnlyPort: 10255
authentication:
  anonymous:
    enabled: false
  webhook:
    cacheTTL: 2m0s
    enabled: true
  x509:
    clientCAFile: /etc/kubernetes/pki/ca.pem
authorization:
  mode: Webhook
  webhook:
    cacheAuthorizedTTL: 5m0s
    cacheUnauthorizedTTL: 30s
cgroupDriver: systemd
cgroupsPerQOS: true
clusterDNS:
- 10.96.0.10
clusterDomain: cluster.local
containerLogMaxFiles: 5
containerLogMaxSize: 10Mi
contentType: application/vnd.kubernetes.protobuf
cpuCFSQuota: true
cpuManagerPolicy: none
cpuManagerReconcilePeriod: 10s
enableControllerAttachDetach: true
enableDebuggingHandlers: true
enforceNodeAllocatable:
- pods
eventBurst: 10
eventRecordQPS: 5
evictionHard:
  imagefs.available: 15%
  memory.available: 100Mi
  nodefs.available: 10%
  nodefs.inodesFree: 5%
evictionPressureTransitionPeriod: 5m0s
failSwapOn: true
fileCheckFrequency: 20s
hairpinMode: promiscuous-bridge
healthzBindAddress: 127.0.0.1
healthzPort: 10248
httpCheckFrequency: 20s
imageGCHighThresholdPercent: 85
imageGCLowThresholdPercent: 80
imageMinimumGCAge: 2m0s
iptablesDropBit: 15
iptablesMasqueradeBit: 14
kubeAPIBurst: 10
kubeAPIQPS: 5
makeIPTablesUtilChains: true
maxOpenFiles: 1000000
maxPods: 110
nodeStatusUpdateFrequency: 10s
oomScoreAdj: -999
podPidsLimit: -1
registryBurst: 10
registryPullQPS: 5
resolvConf: /etc/resolv.conf
rotateCertificates: true
runtimeRequestTimeout: 2m0s
serializeImagePulls: true
staticPodPath: /etc/kubernetes/manifests
streamingConnectionIdleTimeout: 4h0m0s
syncFrequency: 1m0s
volumeStatsAggPeriod: 1m0s
```

启动所有节点kubelet

```
systemctl daemon-reload
systemctl enable --now kubelet
```

此时系统日志/var/log/messages显示只有如下两种信息为正常，安装calico后即可恢复

```
Unable to update cni config: no networks found in /etc/cni/net.d
```

![image-20220823144657197](./images/image-20220823144657197.png)



如果有很多报错日志，或者有大量看不懂的报错，说明kubelet的配置有误，需要检查kubelet配置

 

查看集群状态(Ready或NotReady都正常)

```
[root@k8s-master01 ~]# kubectl get node
```

![image-20220822143840119](./images/image-20220822143840119.png)



### kube-proxy配置



**注意，如果不是高可用集群，192.168.23.100:8443改为master01的地址，8443改为apiserver的端口，默认是6443**

以下操作只在Master01执行

```
cd /root/k8s-ha-install
kubectl -n kube-system create serviceaccount kube-proxy

kubectl create clusterrolebinding system:kube-proxy         --clusterrole system:node-proxier         --serviceaccount kube-system:kube-proxy

SECRET=$(kubectl -n kube-system get sa/kube-proxy \
    --output=jsonpath='{.secrets[0].name}')

JWT_TOKEN=$(kubectl -n kube-system get secret/$SECRET \
--output=jsonpath='{.data.token}' | base64 -d)

PKI_DIR=/etc/kubernetes/pki
K8S_DIR=/etc/kubernetes

kubectl config set-cluster kubernetes     --certificate-authority=/etc/kubernetes/pki/ca.pem     --embed-certs=true     --server=https://192.168.23.100:8443     --kubeconfig=${K8S_DIR}/kube-proxy.kubeconfig

kubectl config set-credentials kubernetes     --token=${JWT_TOKEN}     --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig

kubectl config set-context kubernetes     --cluster=kubernetes     --user=kubernetes     --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig

kubectl config use-context kubernetes     --kubeconfig=/etc/kubernetes/kube-proxy.kubeconfig
```



将kubeconfig发送至其他节点

```
for NODE in k8s-master02 k8s-master03; do
     scp /etc/kubernetes/kube-proxy.kubeconfig  $NODE:/etc/kubernetes/kube-proxy.kubeconfig
done

for NODE in k8s-node01 k8s-node02; do
     scp /etc/kubernetes/kube-proxy.kubeconfig $NODE:/etc/kubernetes/kube-proxy.kubeconfig
done
```

所有节点添加kube-proxy的配置和service文件：

vim /usr/lib/systemd/system/kube-proxy.service

```
[Unit]
Description=Kubernetes Kube Proxy
Documentation=https://github.com/kubernetes/kubernetes
After=network.target

[Service]
ExecStart=/usr/local/bin/kube-proxy \
  --config=/etc/kubernetes/kube-proxy.yaml \
  --v=2

Restart=always
RestartSec=10s

[Install]
WantedBy=multi-user.target
```

**如果更改了集群Pod的网段，需要更改kube-proxy.yaml的clusterCIDR为自己的Pod网段**：

vim /etc/kubernetes/kube-proxy.yaml

```
apiVersion: kubeproxy.config.k8s.io/v1alpha1
bindAddress: 0.0.0.0
clientConnection:
  acceptContentTypes: ""
  burst: 10
  contentType: application/vnd.kubernetes.protobuf
  kubeconfig: /etc/kubernetes/kube-proxy.kubeconfig
  qps: 5
clusterCIDR: 172.16.0.0/12 
configSyncPeriod: 15m0s
conntrack:
  max: null
  maxPerCore: 32768
  min: 131072
  tcpCloseWaitTimeout: 1h0m0s
  tcpEstablishedTimeout: 24h0m0s
enableProfiling: false
healthzBindAddress: 0.0.0.0:10256
hostnameOverride: ""
iptables:
  masqueradeAll: false
  masqueradeBit: 14
  minSyncPeriod: 0s
  syncPeriod: 30s
ipvs:
  masqueradeAll: true
  minSyncPeriod: 5s
  scheduler: "rr"
  syncPeriod: 30s
kind: KubeProxyConfiguration
metricsBindAddress: 127.0.0.1:10249
mode: "ipvs"
nodePortAddresses: null
oomScoreAdj: -999
portRange: ""
udpIdleTimeout: 250ms
```

所有节点启动kube-proxy

```
[root@k8s-master01 k8s-ha-install]# systemctl daemon-reload
[root@k8s-master01 k8s-ha-install]# systemctl enable --now kube-proxy
Created symlink /etc/systemd/system/multi-user.target.wants/kube-proxy.service → /usr/lib/systemd/system/kube-proxy.service.
```





## 网络插件安装

Calico网络插件支持网络策略配置，选用Calico组件作为网络插件

### Calico组件的安装

以下步骤只在master01执行

```
cd /root/k8s-ha-install && git checkout manual-installation-v1.23.x && cd calico/
```

更改calico的网段，主要需要将红色部分的网段，改为自己的Pod网段

```
sed -i "s#POD_CIDR#172.16.0.0/12#g" calico.yaml

```

检查网段是自己的Pod网段：

```
 grep "IPV4POOL_CIDR" calico.yaml  -A 1
```

更改后如下所示

![image-20220823145846981](./images/image-20220823145846981.png)

```
kubectl apply -f calico.yaml
```

查看容器状态：

```
[root@k8s-master01 ~]# kubectl get po -n kube-system
```

![image-20220822144719890](./images/image-20220822144719890.png)

如果容器状态异常可以使用kubectl describe 或者kubectl logs查看容器的日志



查看节点状态：

```
[root@k8s-master01 ~]# kubectl get node -o wide

```

查看结果

```
[root@k8s-master01 calico]# kubectl get node -owide
NAME           STATUS   ROLES    AGE    VERSION    INTERNAL-IP      EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME
k8s-master01   Ready    <none>   119m   v1.23.10   192.168.23.101   <none>        CentOS Linux 7 (Core)   4.19.12-1.el7.elrepo.x86_64   containerd://1.6.7
k8s-master02   Ready    <none>   119m   v1.23.10   192.168.23.102   <none>        CentOS Linux 7 (Core)   4.19.12-1.el7.elrepo.x86_64   containerd://1.6.7
k8s-master03   Ready    <none>   119m   v1.23.10   192.168.23.103   <none>        CentOS Linux 7 (Core)   4.19.12-1.el7.elrepo.x86_64   containerd://1.6.7
k8s-node01     Ready    <none>   119m   v1.23.10   192.168.23.104   <none>        CentOS Linux 7 (Core)   4.19.12-1.el7.elrepo.x86_64   containerd://1.6.7
k8s-node02     Ready    <none>   119m   v1.23.10   192.168.23.105   <none>        CentOS Linux 7 (Core)   4.19.12-1.el7.elrepo.x86_64   containerd://1.6.7
```



## 安装CoreDNS

```
cd /root/k8s-ha-install/
```

**如果更改了k8s service的网段需要将coredns的serviceIP改成k8s service网段的第十个IP**

```
COREDNS_SERVICE_IP=`kubectl get svc | grep kubernetes | awk '{print $3}'`0

sed -i "s#KUBEDNS_SERVICE_IP#${COREDNS_SERVICE_IP}#g" CoreDNS/coredns.yaml
```

安装coredns

```
[root@k8s-master01 k8s-ha-install]#  kubectl  create -f CoreDNS/coredns.yaml 
serviceaccount/coredns created
clusterrole.rbac.authorization.k8s.io/system:coredns created
clusterrolebinding.rbac.authorization.k8s.io/system:coredns created
configmap/coredns created
deployment.apps/coredns created
service/kube-dns created
```



## Metrics部署

在新版的Kubernetes中系统资源的采集均使用Metrics-server，可以通过Metrics采集节点和Pod的内存、磁盘、CPU和网络的使用率。



安装metrics server

```
[root@k8s-master01 ~]# cd /root/k8s-ha-install/metrics-server

[root@k8s-master01 metrics-server]# kubectl  create -f .
```

响应结果

```
serviceaccount/metrics-server created
clusterrole.rbac.authorization.k8s.io/system:aggregated-metrics-reader created
clusterrole.rbac.authorization.k8s.io/system:metrics-server created
rolebinding.rbac.authorization.k8s.io/metrics-server-auth-reader created
clusterrolebinding.rbac.authorization.k8s.io/metrics-server:system:auth-delegator created
clusterrolebinding.rbac.authorization.k8s.io/system:metrics-server created
service/metrics-server created
deployment.apps/metrics-server created
apiservice.apiregistration.k8s.io/v1beta1.metrics.k8s.io created
```



查看状态

```
kubectl get po -n kube-system -l k8s-app=metrics-server
```

![image-20220822145326162](./images/image-20220822145326162.png)



变成1/1   Running后

查看节点使用率

```
[root@k8s-master01 ~]# kubectl top node
```

![image-20220822145539523](./images/image-20220822145539523.png)

查看容器使用率

```
[root@k8s-master01 ~]# kubectl top po -A
```

![image-20220822145649151](./images/image-20220822145649151.png)



## Dashboard部署

Dashboard用于展示集群中的各类资源，同时也可以通过Dashboard实时查看Pod的日志和在容器中执行一些命令等。

### 安装指定版本

```
[root@k8s-master01 ~]# cd /root/k8s-ha-install/dashboard/

[root@k8s-master01 dashboard]# kubectl  create -f .
serviceaccount/admin-user created
clusterrolebinding.rbac.authorization.k8s.io/admin-user created
namespace/kubernetes-dashboard created
serviceaccount/kubernetes-dashboard created
service/kubernetes-dashboard created
secret/kubernetes-dashboard-certs created
secret/kubernetes-dashboard-csrf created
secret/kubernetes-dashboard-key-holder created
configmap/kubernetes-dashboard-settings created
role.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created
rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created
deployment.apps/kubernetes-dashboard created
service/dashboard-metrics-scraper created
deployment.apps/dashboard-metrics-scraper created
```

### 安装最新版本

官方GitHub地址：https://github.com/kubernetes/dashboard

可以在官方dashboard查看到最新版dashboard

![image-20220822150139041](./images/image-20220822150139041.png)



```
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.3/aio/deploy/recommended.yaml
```

以具体版本号为准

```
[root@k8s-master01 ~]# vim admin.yaml

apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-user
  namespace: kube-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding 
metadata: 
  name: admin-user
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "true"
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-user
  namespace: kube-system
```



```
kubectl apply -f admin.yaml -n kube-system
```



### 登录dashboard

在谷歌浏览器（Chrome）启动文件中加入启动参数，用于解决无法访问Dashboard的问题：

```
--test-type --ignore-certificate-errors
```

![image-20220822150503399](./images/image-20220822150503399.png)



更改dashboard的svc为NodePort：

```
kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard
```

![image-20220822150610775](./images/image-20220822150610775.png)

将ClusterIP更改为NodePort（如果已经为NodePort忽略此步骤）：

查看端口号：

```
[root@k8s-master01 dashboard]# kubectl get svc kubernetes-dashboard -n kubernetes-dashboard
NAME                   TYPE       CLUSTER-IP    EXTERNAL-IP   PORT(S)         AGE
kubernetes-dashboard   NodePort   10.96.92.22   <none>        443:30923/TCP   2m28s

```





根据自己的实例端口号，通过任意安装了kube-proxy的宿主机的IP+端口即可访问到dashboard：

访问Dashboard：[https://192.168.23.101:30923（请更改30923为自己的端口）](https://10.103.236.201:30923（请更改30923为自己的端口）)，选择登录方式为令牌（即token方式）

![image-20220822150922234](./images/image-20220822150922234.png)

查看token值：

```
[root@k8s-master01 1.1.1]# kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')
Name:         admin-user-token-r4vcp
Namespace:    kube-system
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: admin-user
              kubernetes.io/service-account.uid: 2112796c-1c9e-11e9-91ab-000c298bf023

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  11 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXI0dmNwIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIyMTEyNzk2Yy0xYzllLTExZTktOTFhYi0wMDBjMjk4YmYwMjMiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZS1zeXN0ZW06YWRtaW4tdXNlciJ9.bWYmwgRb-90ydQmyjkbjJjFt8CdO8u6zxVZh-19rdlL_T-n35nKyQIN7hCtNAt46u6gfJ5XXefC9HsGNBHtvo_Ve6oF7EXhU772aLAbXWkU1xOwQTQynixaypbRIas_kiO2MHHxXfeeL_yYZRrgtatsDBxcBRg-nUQv4TahzaGSyK42E_4YGpLa3X3Jc4t1z0SQXge7lrwlj8ysmqgO4ndlFjwPfvg0eoYqu9Qsc5Q7tazzFf9mVKMmcS1ppPutdyqNYWL62P1prw_wclP0TezW1CsypjWSVT4AuJU8YmH8nTNR1EXn8mJURLSjINv6YbZpnhBIPgUGk1JYVLcn47w
```

将token值输入到令牌后，单击登录即可访问Dashboard

![image-20220822151126895](./images/image-20220822151126895.png)









# 集群验证

安装busybox

```
cat<<EOF | kubectl apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: busybox
  namespace: default
spec:
  containers:
  - name: busybox
    image: busybox:1.28
    command:
      - sleep
      - "3600"
    imagePullPolicy: IfNotPresent
  restartPolicy: Always
EOF
```



## kubernetes svc网络验证

每个节点都必须要能访问Kubernetes的kubernetes svc 443

查看k8s service的网络地址：

```
[root@k8s-master01 ~]# kubectl get svc
NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   64m
```

测试所有节点是否能连通k8s service的网络

```
[root@k8s-master01 ~]#  telnet 10.96.0.1 443
Trying 10.96.0.1...
Connected to 10.96.0.1.
Escape character is '^]'.
quit
Connection closed by foreign host.
```



## kube-dns svc网络验证

每个节点都必须要能访问Kubernetes的kube-dns的service 53

验证kube-dns 网络是否连通,kube-dns 的service在kube-system，查看kube-dns的service地址

```
[root@k8s-master01 ~]# kubectl get svc -n kube-system
NAME             TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                  AGE
calico-typha     ClusterIP   10.109.55.10    <none>        5473/TCP                 55m
kube-dns         ClusterIP   10.96.0.10      <none>        53/UDP,53/TCP,9153/TCP   72m
metrics-server   ClusterIP   10.107.98.242   <none>        443/TCP                  39m
```

测试所有节点是否能连通kube-dns的网络

```
[root@k8s-master01 ~]# telnet 10.96.0.10 53
Trying 10.96.0.10...
Connected to 10.96.0.10.
Escape character is '^]'.
Connection closed by foreign host.
```



## Pod和Pod连通性验证

### pod同namespace能通信



### pod跨namespace通信验证

测试pod网段是否连通：

```
[root@k8s-master01 ~]# kubectl  get po -o wide --all-namespaces
NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE   IP               NODE           NOMINATED NODE   READINESS GATES
kube-system            calico-kube-controllers-6f6595874c-kvbpl     1/1     Running   0             62m   172.17.125.3     k8s-node01     <none>           <none>
kube-system            etcd-k8s-master01                            1/1     Running   0             78m   192.168.23.101   k8s-master01   <none>           <none>
```

所有节点测试 pod的地址172.17.125.3是否都能ping通：

```
[root@k8s-master01 ~]# ping 172.17.125.3
PING 172.17.125.3 (172.17.125.3) 56(84) bytes of data.
64 bytes from 172.17.125.3: icmp_seq=1 ttl=63 time=0.533 ms
64 bytes from 172.17.125.3: icmp_seq=2 ttl=63 time=0.537 ms
^C
--- 172.17.125.3 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1056ms
rtt min/avg/max/mdev = 0.533/0.535/0.537/0.002 ms

```



### Pod跨机器通信验证

测试不同机器pod与pod网络是否连通：

```
[root@k8s-master01 ~]# kubectl  get po -o wide --all-namespaces
NAMESPACE              NAME                                         READY   STATUS    RESTARTS      AGE   IP               NODE           NOMINATED NODE   READINESS GATES
kube-system            calico-kube-controllers-6f6595874c-kvbpl     1/1     Running   0             62m   172.17.125.3     k8s-node01     <none>           <none>
kube-system            calico-node-xlmgm                            1/1     Running   0             62m   192.168.23.105   k8s-node02     <none>           <none>
```

进入calico-node-xlmgm容器：

```
kubectl exec -it calico-node-xlmgm -n kube-system --sh
```

验证是否能ping通k8s-node01的容器网络地址

```
ping 172.17.125.3
```





## Pod必须能解析Service

```
[root@k8s-master01 ~]# kubectl exec  busybox -n default -- nslookup kubernetes
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kubernetes
Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local
```



## Pod必须能解析跨namespace的Service

```
[root@k8s-master01 ~]#  kubectl exec  busybox -n default -- nslookup kube-dns.kube-system
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      kube-dns.kube-system
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local
```





# 生产环境关键性配置

**关键性配置请参考视频，不要直接配置！**

Docker配置 采用containerd作为Runtime无需配置

vim /etc/docker/daemon.json

```
{
 "registry-mirrors": [
    "https://registry.docker-cn.com",
    "http://hub-mirror.c.163.com",
    "https://docker.mirrors.ustc.edu.cn"
  ],
 "exec-opts": ["native.cgroupdriver=systemd"],
 "max-concurrent-downloads": 10, 
 "max-concurrent-uploads": 5, 
 "log-opts": { 
   "max-size": "300m", 
   "max-file": "2" 
 }, 
 #重启docker,容器不会重启
 "live-restore": true 
} 
```



vim /usr/lib/systemd/system/kube-controller-manager.service

```
#注释这一项，新版是默认打开的
# --feature-gates=RotateKubeletClientCertificate=true,RotateKubeletServerCertificate=true \
#添加集群证书过期时间
--cluster-signing-duration=876000h0m0s \
```



vim /etc/systemd/system/kubelet.service.d/10-kubelet.conf

```
[Service]

Environment="KUBELET_KUBECONFIG_ARGS=--kubeconfig=/etc/kubernetes/kubelet.kubeconfig --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.kubeconfig"

Environment="KUBELET_SYSTEM_ARGS=--network-plugin=cni --cni-conf-dir=/etc/cni/net.d --cni-bin-dir=/opt/cni/bin"

Environment="KUBELET_CONFIG_ARGS=--config=/etc/kubernetes/kubelet-conf.yml  --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.6"

Environment="KUBELET_EXTRA_ARGS=--tls-cipher-suites=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384    --image-pull-progress-deadline=30m"

ExecStart=

ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_SYSTEM_ARGS $KUBELET_EXTRA_ARGS
```



**关键性配置请参考视频，不要直接配置，可能会造成集群故障！！**

vim /etc/kubernetes/kubelet-conf.yml

根据系统配置设置资源预留:

```
rotateServerCertificates: true
allowedUnsafeSysctls:
 - "net.core*"
 - "net.ipv4.*"
kubeReserved:
  cpu: "1"
  memory: 1Gi
  ephemeral-storage: 10Gi
systemReserved:
  cpu: "1"
  memory: 1Gi
  ephemeral-storage: 10Gi
```

重启kubelet

```
systemctl daemon-reload
systemctl restart kubelet
```





安装总结：

1、 kubeadm

2、 二进制

3、 自动化安装

​       a) Ansible

​       i. Master节点安装不需要写自动化。

​       ii. 添加Node节点，playbook。

4、 安装需要注意的细节

​      a) 上面的细节配置

​      b) 生产环境中etcd一定要和系统盘分开，一定要用ssd硬盘。

​      c) Docker数据盘也要和系统盘分开，有条件的话可以使用ssd硬盘





# kubelet启动过程

1.查找kubeconfig文件，文件一般位于/etc/kubernates/kubelet.kubeconfig

2.从kubeconfig 文件中检索APIServer的URL和证书

3.然后去和APIServer进行交互



# Bootstrapping 申请和颁发证书原理

```
1.kubelet 启动

2.kubelet 查看kubelet.kubeconfig文件，假如没有这个文件

3.kubelet 会查看本地的bootstrap.kubeconfig

4.kubelet 读取bootstrap.kubeconfig文件，检索apiserver的url和一个token

5.kubelet 链接apiserver，使用这个token进行认证

​    a)apiserver 会识别这个tokenid,apiserver会查看该tokenid对应的bootstrap的一个sercret

​    b)apiserver把这个token识别成一个username，名称是system:bootstrap:<token-id>，属于system:bootstrappers这个组，这个组具有申请csr的权限，该组的权限绑定在一个叫system:node-bootstrap的clusterrole

​	c)CSR:相当于一个申请表，可以拿这个申请表去申请我们的证书

6. 经过上面的认证，kubelet就有了一个创建和检索的csr权限

7.kubelet为自己创建一个CSR,名称为kubernetes.io/kube-apiserver-client-kubelet

8.CSR被允许有两种方式
 a)k8s管理员使用kubectl 手动的颁发证书
 b)如果配置了相关权限，kube-controller-manager会自动同意
   b1)controller-manager 有一个CSRApprovingController，他会校验kubelet发来的crs的username和group是否有创建csr的权限，而且还要验证签发的是否是kubernetes.io/kube-apiserver-client-kubelet
   b2)controller-manager 同意CSR请求

9.CSR被同意后，controller-manager 创建kubelet的证书文件

10.controllermanager将证书更新至csr的status字段

11.kubelet 从apiserver获取证书

12.Kubelet 从获取到的key和证书文件创建kubelet.kubeconfig文件

13.kubelet启动完成并正常工作

14. 可选:如果配置了自动续期,kubelet会在证书文件过期的时候利用之前的kubeconfig文件去申请一个新的证书，相当于续约

15.新的证书被同意或签发，取决于我们的配置
   a)kubelet创建的csr属于一个组:system:nodes
   b)CN：systemnodes主机名

```

